    package main

    import (
    	"encoding/base64"
    	"encoding/json"
    	"fmt"
    	"log"
    	"os"
    	"os/signal"
    	"syscall"
    	"strconv"
    	"strings"

    	abci_server "github.com/cometbft/cometbft/abci/server"
    	abci_types "github.com/cometbft/cometbft/api/cometbft/abci/v1" // Correct import for CometBFT v1.0.x
    )

    // TransferTransaction defines the structure for the incoming JSON transaction
    // It must EXACTLY match the JSON generated by your Python app.
    type TransferTransaction struct {
    	Type      string `json:"type"`
    	FromNode  string `json:"from_node"`
    	ToNode    string `json:"to_to_node"` // Typo fix: Changed ToNode to to_node
    	Amount    string `json:"amount"` // e.g., "50 tokens"
    	Timestamp string `json:"timestamp"`
    }

    // MyApp represents your custom ABCI application state.
    type MyApp struct {
    	abci_types.BaseApplication
    	lastBlockHeight int64
    	appHash         []byte
    }

    // NewMyApp creates and initializes a new instance of your ABCI application.
    func NewMyApp() *MyApp {
    	return &MyApp{
    		lastBlockHeight: 0,
    		appHash:         []byte("initial_app_hash"),
    	}
    }

    // Info is called to get information about the application.
    func (app *MyApp) Info(req abci_types.RequestInfo) abci_types.ResponseInfo {
    	log.Printf("ABCI Info: Received RequestInfo. Version: %s, BlockVersion: %d, P2PVersion: %d, ABCIVersion: %s",
    		req.Version, req.BlockVersion, req.P2PVersion, req.AbciVersion)
    	
    	return abci_types.ResponseInfo{
    		Version:         "1.0.0", // Your application's version
    		AppVersion:      1,
    		LastBlockHeight: app.lastBlockHeight,
    		LastBlockAppHash: app.appHash,
    		LastConsensusBlockHeight: app.lastBlockHeight,
    		LastConsensusAppHash: app.appHash,
    		Data: "",
    		ProtocolVersion: 0,
    	}
    }

    // InitChain is called once upon genesis, when the blockchain is initialized.
    func (app *MyApp) InitChain(req abci_types.RequestInitChain) abci_types.ResponseInitChain {
    	log.Println("ABCI InitChain: Initializing minimal application state.")
    	app.lastBlockHeight = req.InitialHeight
    	app.appHash = []byte("initial_app_hash_after_init")
    	log.Printf("ABCI InitChain: Initialized at Height %d with AppHash %x", app.lastBlockHeight, app.appHash)
    	return abci_types.ResponseInitChain{}
    }

    // CheckTx is called to validate a transaction before it enters the mempool.
    func (app *MyApp) CheckTx(req abci_types.RequestCheckTx) abci_types.ResponseCheckTx {
    	log.Printf("ABCI CheckTx: Received raw transaction bytes (Base64 string): %s", string(req.Tx))

    	decodedJSONBytes, err := base64.StdEncoding.DecodeString(string(req.Tx))
    	if err != nil {
    		logMsg := fmt.Sprintf("ABCI CheckTx ERROR: Failed to Base64 decode transaction: %v", err)
    		log.Println(logMsg)
    		return abci_types.ResponseCheckTx{Code: 2, Log: logMsg}
    	}
    	log.Printf("ABCI CheckTx: Successfully Base64 decoded to raw JSON bytes: %s", string(decodedJSONBytes))

    	var tx TransferTransaction
    	err = json.Unmarshal(decodedJSONBytes, &tx)
    	if err != nil {
    		logMsg := fmt.Sprintf("ABCI CheckTx ERROR: Failed to unmarshal JSON: %v. Decoded payload was: %s", err, string(decodedJSONBytes))
    		log.Println(logMsg)
    		return abci_types.ResponseCheckTx{Code: 2, Log: logMsg}
    	}
    	log.Printf("ABCI CheckTx: Successfully unmarshaled transaction: %+v", tx)

    	if tx.Type == "" || tx.FromNode == "" || tx.ToNode == "" || tx.Amount == "" || tx.Timestamp == "" {
    		logMsg := "ABCI CheckTx ERROR: Missing one or more required fields (type, from_node, to_node, amount, timestamp)."
    		log.Println(logMsg)
    		return abci_types.ResponseCheckTx{Code: 4, Log: logMsg}
    	}

    	amountStr := strings.TrimSuffix(tx.Amount, " tokens")
    	if _, err := strconv.Atoi(amountStr); err != nil {
    		logMsg := fmt.Sprintf("ABCI CheckTx ERROR: Invalid amount format: %s", tx.Amount)
    		log.Println(logMsg)
    		return abci_types.ResponseCheckTx{Code: 5, Log: logMsg}
    	}

    	log.Println("ABCI CheckTx: Transaction passed minimal format validations. Returning Code 0.")
    	return abci_types.ResponseCheckTx{Code: 0, Log: "Transaction format OK."}
    }

    // DeliverTx is called when a transaction is included in a block and committed.
    func (app *MyApp) DeliverTx(req abci_types.RequestDeliverTx) abci_types.ResponseDeliverTx {
    	log.Printf("ABCI DeliverTx: Processing transaction for block: %s", string(req.Tx))

    	decodedJSONBytes, err := base64.StdEncoding.DecodeString(string(req.Tx))
    	if err != nil {
    		logMsg := fmt.Sprintf("ABCI DeliverTx ERROR: Failed to Base64 decode: %v", err)
    		log.Println(logMsg)
    		return abci_types.ResponseDeliverTx{Code: 2, Log: logMsg}
    	}
    	var tx TransferTransaction
    	err = json.Unmarshal(decodedJSONBytes, &tx)
    	if err != nil {
    		logMsg := fmt.Sprintf("ABCI DeliverTx ERROR: Failed to unmarshal JSON: %v. Payload: %s", err, string(decodedJSONBytes))
    		log.Println(logMsg)
    		return abci_types.ResponseDeliverTx{Code: 2, Log: logMsg}
    	}

    	log.Printf("ABCI DeliverTx: Successfully processed transaction (no state change): %+v", tx)
    	return abci_types.ResponseDeliverTx{Code: 0, Log: "Transaction delivered (no state change)."}
    }

    // BeginBlock is called before any transactions are delivered in a block.
    func (app *MyApp) BeginBlock(req abci_types.RequestBeginBlock) abci_types.ResponseBeginBlock {
    	app.lastBlockHeight = req.Header.Height
    	app.appHash = []byte(fmt.Sprintf("app_hash_at_height_%d", req.Header.Height))
    	log.Printf("ABCI BeginBlock: Height %d, Hash %x, New AppHash: %x", req.Header.Height, req.Hash, app.appHash)
    	return abci_types.ResponseBeginBlock{}
    }

    // EndBlock is called after all transactions are delivered in a block.
    func (app *MyApp) EndBlock(req abci_types.RequestEndBlock) abci_types.ResponseEndBlock {
    	log.Printf("ABCI EndBlock: Height %d", req.Height)
    	return abci_types.ResponseEndBlock{}
    }

    // Commit is called to persist the current application state.
    func (app *MyApp) Commit() abci_types.ResponseCommit {
    	log.Printf("ABCI Commit: Committing state at height %d with AppHash %x", app.lastBlockHeight, app.appHash)
    	return abci_types.ResponseCommit{Data: app.appHash}
    }

    // The main function to start the ABCI server.
    func main() {
    	app := NewMyApp()

    	addr := "unix:///home/shuddhank/gopyserf/abci_app/abci_app_executable.sock"
    	if len(os.Args) > 1 {
    		addr = os.Args[1]
    	}

    	if strings.HasPrefix(addr, "unix://") {
    		socketPath := strings.TrimPrefix(addr, "unix://")
    		if _, err := os.Stat(socketPath); err == nil {
    			if err := os.Remove(socketPath); err != nil {
    				log.Fatalf("Failed to remove old unix socket file %s: %v", socketPath, err)
    			}
    			log.Printf("Removed old unix socket file: %s", socketPath)
    		}
    	}

    	server := abci_server.NewSocketServer(addr, app)

    	log.Printf("ABCI server listening on %s", addr)
    	if err := server.Start(); err != nil {
    		log.Fatalf("Error starting ABCI server: %v", err)
    	}

    	c := make(chan os.Signal, 1)
    	signal.Notify(c, os.Interrupt, syscall.SIGTERM)
    	<-c

    	log.Println("Shutting down ABCI server gracefully...")
    	if err := server.Stop(); err != nil {
    		log.Fatalf("Error stopping ABCI server: %v", err)
    	}
    	log.Println("ABCI server stopped.")
    }
    
